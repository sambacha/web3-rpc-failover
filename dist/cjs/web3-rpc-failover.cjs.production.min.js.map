{"version":3,"file":"web3-rpc-failover.cjs.production.min.js","sources":["../src/module/configParser.ts","../src/module/providerEndpoint.ts","../src/module/FailOverProvider.ts"],"sourcesContent":["/**\n * @file configParser\n */\nimport * as fs from 'fs';\nimport * as yaml from 'yaml';\n\n/**\n * @const getConfig\n * @summary Get and Parse the Config from the root directory\n */\n\nconst getConfig = (configPath: any) => {\n  const configFile = fs.readFileSync(configPath, 'utf8');\n  return yaml.parse(configFile);\n};\n\nexport default getConfig;\n/** @exports getConfig */\n","import * as providers from '@ethersproject/providers';\n\n/**\n * @file providerEndpoint\n * @summary url to provider\n */\n\n/**\n *  @const providerEndpoint\n *  @summary Coerces a URL into its respective provider\n *  @param {string} url RPC/WS Endpoint\n *  @param {string} networkId of chain\n *  @note this is defined in a `.yaml` configuration file\n */\n\nconst providerEndpoint = (url: any, networkId: any) => {\n  if (url.startsWith('http')) {\n    return new providers.JsonRpcProvider(url, networkId);\n  } else if (url.startsWith('ws')) {\n    return new providers.WebSocketProvider(url, networkId);\n  } else {\n    throw new Error('Could not resolve url to provider');\n  }\n};\n\n//module.exports = providerEndpoint;\nexport default providerEndpoint;\n/** @exports providerEndpoint */\n","/**\n * @packageName Web3 RPC FailOverProvider\n * @license MIT\n * @version 1.3.0\n */\n\nimport * as providers from '@ethersproject/providers';\n\nimport getConfig from './configParser';\nimport providerEndpoint from './providerEndpoint';\n\n// or {[k: string]: never}\ntype EmptyObject = Record<string, never>;\n\n/**\n * @class FailOverProvider\n * @summary Fallback Provider which is capable of connecting to multiple back ends\n */\nexport class FailOverProvider {\n  config: any;\n  provider: any;\n\n  /**\n   * Generates the fallback provider from given config\n   * @param {path} pathToConfig\n   */\n  constructor(pathToConfig: any) {\n    this.config = getConfig(pathToConfig);\n    const providerConfig = this.config.providers.map((provider: any) => {\n      const f: EmptyObject = {};\n      const config = f;\n      // getNetwork.bind(null, provider.network));\n      (config as any).provider = providerEndpoint(provider.url, provider.networkId);\n      Object.assign(config, provider.config);\n      return config;\n    });\n    this.provider = new providers.FallbackProvider(providerConfig);\n  }\n\n  /**\n   * Returns the fallback provider\n   * @return {provider}\n   */\n\n  get() {\n    return this.provider;\n  }\n}\n"],"names":["getConfig","configPath","configFile","fs","yaml","providerEndpoint","url","networkId","startsWith","providers","Error","pathToConfig","config","providerConfig","this","map","provider","Object","assign","get"],"mappings":"gJAWMA,EAAY,SAACC,OACXC,EAAaC,eAAgBF,EAAY,eACxCG,QAAWF,ICEdG,EAAmB,SAACC,EAAUC,MAC9BD,EAAIE,WAAW,eACV,IAAIC,kBAA0BH,EAAKC,GACrC,GAAID,EAAIE,WAAW,aACjB,IAAIC,oBAA4BH,EAAKC,SAEtC,IAAIG,MAAM,qFCKNC,QACLC,OAASZ,EAAUW,OAClBE,EAAiBC,KAAKF,OAAOH,UAAUM,KAAI,SAACC,OAE1CJ,EADiB,UAGtBA,EAAeI,SAAWX,EAAiBW,EAASV,IAAKU,EAAST,WACnEU,OAAOC,OAAON,EAAQI,EAASJ,QACxBA,UAEJI,SAAW,IAAIP,mBAA2BI,sBAQjDM,IAAA,kBACSL,KAAKE"}